<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.21">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Emily Nordmann">
<meta name="dcterms.date" content="2023-07-23">

<title>Using ChatGPT for learning &amp; teaching: Correcting auto-transcripts – Emily Nordmann</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-7e9717d9caa9b4d114d189eaeb260ada.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea1d7ac60288e0f1efdbc993fd8432ae.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-bae33c85dea990b555726d9e885fc0e5.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-e31584831b205ffbb2d98406f31c2a5b.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Emily Nordmann</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../post.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../contact.html"> 
<span class="menu-text">Contact</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../files/cv.pdf"> 
<span class="menu-text">CV</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Using ChatGPT for learning &amp; teaching: Correcting auto-transcripts</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Emily Nordmann </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 23, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Alongside Wil Tovio and Rachel O’Neill, I’ve written before in the <a href="https://www.timeshighereducation.com/campus/new-rules-lecture-transcripts-give-academics-impossible-choice">Times Higher</a> about the problems that requiring academics to produce corrected captions introduces. If you don’t do it, you disadvantage a wide range of students and effectively ruin the education of those who are d/Deaf and hard-of-hearing. If you do, you put a much higher workload burden on any lecturer with a “non-standard” accent, those with poorer quality recording equipment, and let’s honest, those who just care a bit more. I say all of this whilst recognising my own privilege: most recording software generally picks up what I am saying accurately and through both work and personal means, I invested in a high-quality mic at the start of covid.</p>
<section id="correcting-transcripts" class="level2">
<h2 class="anchored" data-anchor-id="correcting-transcripts">Correcting transcripts</h2>
<p>But anyway. It just occurred to me that one use of ChatGPT that falls under the category “let’s make the admin associated with teaching easier” is that we might be able to use it to edit transcriptions for us. And for once, I actually have the means to evaluate how it’s done in the form of an original automated-transcription, the corrected version a human spent hours on, and the audio. The video in question was a walkthrough of a data skills tutorial in R, and platforms like Zoom and Echo360 tend to struggle with the technical terminology.</p>
<p>I downloaded the original transcript as a .txt file from Echo360 and put the following prompt into ChatGPT. I’ve got a paid subscription and access to GPT4.0 but I chose to use GPT3.5 as that’s the one most people have access to.</p>
<blockquote class="blockquote">
<p>Act like an expert in the programming language R. I have recorded a lecture which is a walkthrough video of a tutorial in R. The learning outcomes are: Be able to reshape data between long and wide formats; Separate, change, reorder, and rename columns; Use pipes to chain together functions. Recording software has automatically transcribed the recording but there are many errors. Below is the transcript, correct the transcription errors.</p>
</blockquote>
<p>The full transcript is much longer than ChatGPT can take in one response so you either have to do it bit by bit, or tell it you’re going to split the document and not to proceed until you tell it you’re finished. For the purposes of this tutorial, I just copied and pasted what I thought would fit.</p>
<p>Once it produced the corrected transcript I then asked:</p>
<blockquote class="blockquote">
<p>Tell me what you changed and give me the original and the corrected version so I can easily compare them.</p>
</blockquote>
<p>It gave me a list of 7 changes it had made, I won’t list them all but how did it do?</p>
<ul>
<li><strong>Original</strong>: “So now that we have looked that in and will open up a new a junk…”<br>
</li>
<li><strong>Corrected by ChatGPT:</strong> “So now that we have loaded that in, let’s open up a new chunk…”<br>
</li>
<li><strong>Corrected by human:</strong> “So now that we have locked that in, I will open up a new a chunk”</li>
</ul>
<p>Listening to the audio, you could sensibly conclude it was either “loaded” or “locked”, (the human doing the editing wasn’t the human doing the lecture) and both make sense in context. For the second part of the sentence, the audio is a bit disfluent, both the human and ChatGPT have corrected it to what was clearer the intent of the sentence and whilst they’re different, they both work.</p>
<ul>
<li><strong>Original</strong>: “Let’s compare this to a version of this table, but in completely tiny format”</li>
<li><strong>Corrected by ChatGPT</strong>: “Let’s compare this to a version of this table but in a completely tidy format”<br>
</li>
<li><strong>Corrected by human:</strong> “Let’s compare this to a version of this table, but in completely tidy format.”</li>
</ul>
<p>ChatGPT and the human produced the same correction.</p>
<ul>
<li><strong>Original</strong>:“…we now have three columns here where each column is its own variable one just four items, one just for the price per item and one just for the total price, and they are distinguished by this for scoring here.”<br>
</li>
<li><strong>Corrected by ChatGPT</strong>: “…we now have three columns here: one just for items, one just for the price per item, and one just for the total price, and they are distinguished by this ‘year’ column.”<br>
</li>
<li><strong>Corrected by human:</strong> “we now have three columns here where each column is its own variable one just for items, one just for the price per item and one just for the total price, and they are distinguished by this fourth column here - year.</li>
</ul>
<p>ChatGPT has removed a few words “here each column is its own variable” which in this case doesn’t really affect the overall meaning in the context of the wider section but if it’s going to do that you’d want to make sure you’re checking each correction.</p>
</section>
<section id="the-whole-truth-and-nothing-but-the-truth" class="level2">
<h2 class="anchored" data-anchor-id="the-whole-truth-and-nothing-but-the-truth">The whole truth and nothing but the truth</h2>
<p>Whilst it gave me 7 corrections, I could see that it had made more than the initial list it gave so I followed up:</p>
<blockquote class="blockquote">
<p>These aren’t all the changes, tell me everything you changed</p>
</blockquote>
<p>And it then produced a list of 18 changes, apologising for the oversight. So I probed further:</p>
<blockquote class="blockquote">
<p>Is this a complete list of all changes now or are there more?</p>
</blockquote>
<p>It then gave me an additional extra change. Hmmm. The text file dumps the transcription into one big block of text, but Echo360 also gives the option to download the .VTT file that has it line-by-line with time-stamps e.g.:</p>
<blockquote class="blockquote">
<p>00:00:21.110 –&gt; 00:00:24.680 &lt;v Speaker 0&gt;So as usual, we’re going to start off by creating</p>
</blockquote>
<blockquote class="blockquote">
<p>NOTE CONF {“raw”:[100,100,100,52,93,100,100,100,100,100]} 00:00:24.680 –&gt; 00:00:27.860 &lt;v Speaker 0&gt;a new project for this chapter so that we can</p>
</blockquote>
<blockquote class="blockquote">
<p>NOTE CONF {“raw”:[100,100,94,100,100,100,100,100,100,100]} 00:00:27.860 –&gt; 00:00:29.570 &lt;v Speaker 0&gt;work through things together.</p>
</blockquote>
<p>I thought that maybe chunking the text a bit would help it be able to identify the changes but all it did was render the correction completely useless. Splitting up the text with the time stamps appears to stop it being able to parse it properly which is interesting in a way that makes me realise I’ve got no idea what’s going on under the hood.</p>
</section>
<section id="no-single-truth" class="level2">
<h2 class="anchored" data-anchor-id="no-single-truth">No single truth</h2>
<p>My internet acted up and I couldn’t access the chat I was having for this blog so I redid the prompt in a new chat, with the same prompt and section of the script.</p>
<p>This time it gave me 33 changes. Some of them were the same, some of them were different. Which is not surprising because that’s how ChatGPT works, it’s all prediction and you can use the regenerate response option to get a slightly different version if you’re not happy with whatever it has produced. But in the context of transcription, it’s a really useful reminder that it isn’t “correcting” it, it’s doing what it normally does which is predicting what word should come next. It doesn’t have the source audio, it’s not doing what an underpaid human would be doing.</p>
<p>It’s possible that had I initially asked it “give me a complete list of all changes, leave nothing out”, it wouldn’t have missed any. But also, it is well-known that you can “trick” ChatGPT into thinking it’s wrong just by telling it that it is:</p>
<p><img src="images/Screenshot 2023-07-23 172451.png" class="img-fluid"></p>
<p>So it could be that my follow-up prompts insisting it had missed something resulted in it making up new prompts to satisfy the monkey at its typewriter. In a nutshell, you can’t use ChatGPT to verify what ChatGPT has produced. The snake will eat its own tail.</p>
<p>More worryingly, in additional attempts both with 3.5 and GPT4.0, it started editing more than you’d want for a transcription correction. For example:</p>
<blockquote class="blockquote">
<p>Before we go any further here, I’m going to to switch to year. As you can see, we’re going to switch to this year. So hopefully you are now seeing my internet browser,</p>
</blockquote>
<p>Consulting the audio, this should be “I’m going to switch to share, as you can see, I’m going to switch to this here. So hopefully you are now seeing my internet browser”. It’s not a sentence that makes a great deal of sense without the video (which is describing changing what is being shared on the screen) but that’s what you’d want the transcript to say because alongside the video it does make sense.</p>
<p>This is what ChatGPT changed it to:</p>
<blockquote class="blockquote">
<p>Before we delve deeper, I’m going to switch screens. You should now see my internet browser.</p>
</blockquote>
<p>Which makes a lot more sense except for the fact it doesn’t actually represent what was said.</p>
</section>
<section id="maybe-were-asking-the-wrong-questions" class="level2">
<h2 class="anchored" data-anchor-id="maybe-were-asking-the-wrong-questions">Maybe we’re asking the wrong questions</h2>
<p>This feels like a task ChatGPT should be able to perform so I became slightly obsessed and starting trying different prompts, convinced that maybe the issue was that I wasn’t being specific enough:</p>
<blockquote class="blockquote">
<p>Act like a video editor who is an expert in the programming language R who has been asked to correct a transcript for the subtitles of a recorded lecture which is a walkthrough video of a tutorial in R.</p>
</blockquote>
<blockquote class="blockquote">
<p>The learning outcomes are: Be able to reshape data between long and wide formats; Separate, change, reorder, and rename columns; Use pipes to chain together functions.</p>
</blockquote>
<blockquote class="blockquote">
<p>Recording software has automatically transcribed the recording but there are many errors where the transcription software has not accurately assessed what word has been said. Below is the transcript, edit all words that are likely to be transcription errors so that they can be used as subtitles. Do not edit anything that is not likely to be an error and do not paraphrase or change the meaning.</p>
</blockquote>
<p>This seemed to keep to the brief of not changing the meaning a lot better although it was perhaps a little too conservative (but if the option is change too much or too little, perhaps that’s for the best). Additionally it didn’t get everything right (e.g., 2 and 4 aren’t right but I suppose they’re no more wrong than the original automated transcript so it is at least not changing things that aren’t wrong).</p>
<p><img src="images/Screenshot 2023-07-24 083018.png" class="img-fluid"></p>
</section>
<section id="is-this-any-use" class="level2">
<h2 class="anchored" data-anchor-id="is-this-any-use">Is this any use?</h2>
<p>The question is then, given all these issues, is this any use? The edits it produced on my first attempt were really very impressive and reading through the edited transcript, it all made sense and I was getting very excited. But as I kept going I got more and more cautious. In some cases it’s not necessarily problematic that it wasn’t a one-to-one correction, the human also made some choices that deviated from an exact script to make it make sense, but without a lot of work on the prompt in some cases ChatGPT was paraphrasing way beyond the original intent and meaning. I was forced to remind myself that it’s not “correcting” words and it doesn’t have access to the audio. Additionally, it’s very difficult to get it to tell you everything it changed so you absolutely couldn’t use this without verifying it.</p>
<p>On my first attempt, the amount it got right would hugely cut-down on the time it takes to correct a transcript and a more specific prompt seemed to solve some of the issues with paraphrasing. It was certainly still better than the automated transcript, so one possible option could be to take the original, run it through ChatGPT, and then get a human to correct the ChatGPT version. That way, you make the workload more manageable, but you still have human eyes on it.</p>
<p>I think whether or not it is worth it probably depends on how much transcription you have to do. If you have hours and hours of recorded content to transcribe then it is probably worth training ChatGPT to do exactly what you want and to take the time to build the prompts and find a balance you’re happy with because in the long-run it will still save huge amounts of time. However, if I had a single video, I’m not sure I would currently bother as it probably takes enough work to get it right than it does just to do it manually.</p>
<p>This blog feels like a stream-of-consciousness but what this process has done is change the way I would approach using ChatGPT to edit anything. I’m currently working on guidance for essay writing for students and I think my experience here has taught me that I wouldn’t ask it to edit anything directly but instead to give suggestions alongside the original. For the purposes of transcription correction, that process makes it time-consuming but for an essay or any other piece of writing, it would ensure you’re making active choices.</p>
<p>Another consideration is privacy. If you upload your transcripts, you’re essentially giving OpenAI your lecture to help train its LLM <a href="https://openai.com/blog/new-ways-to-manage-your-data-in-chatgpt">unless you change the default settings</a>. Whether you care about that is up to you, but make a conscious choice.</p>
<p>And finally, none of this changes the fact that the problem with the workload involved with transcription will still be higher for people working in their second language and those who have regional accents and that academic workload modelling is a complete joke.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/www\.emilynordmann\.com\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>
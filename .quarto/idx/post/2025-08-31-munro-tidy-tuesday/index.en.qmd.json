{"title":"Munro Tidy Tuesday","markdown":{"yaml":{"title":"Munro Tidy Tuesday","author":"Emily Nordmann","date":"2025-08-31","slug":"munro-tidy-tuesday","format":{"html":{"code-fold":true,"code-summary":"Show code","toc":true,"toc-location":"left"}},"execute":{"warning":false,"message":false}},"headingText":"Walkhighlands munro info","containsRefs":false,"markdown":"\n\n\nI was immediately obsessed when I saw the Tidy Tuesday theme was [Scottish Munros](https://github.com/rfordatascience/tidytuesday/blob/main/data/2025/2025-08-19/readme.md) - we have climbed 58/282 so far. As I assume is the case for the majority of baggers, we use  [walkhighlands](https://www.walkhighlands.co.uk/) for all our munro info and routes. walkhighlands is one of the unequivocally wonderful bits of the internet and I can't believe it's free. We [donate](https://www.walkhighlands.co.uk/donate.shtml) to keep it going, and if you're a bagger who uses it often, I'd encourage you to do the same. When I saw the Tidy Tuesday dataset, I knew I wanted to try and combine the provided data from the [Database of British and Irish Hills v18.2](https://www.hills-database.co.uk/) with what's available on walkhighlands.   \n\nBecause I've made certain career choices, my day-to-day activity now involves a lot less coding and a lot more admin and I realised I was starting to lose some of my R so this has been a nice excuse to refresh. I'm gearing up for another semester of teaching R to students in the age of AI and it has been interesting to reflect on how I'm using AI myself. Pleasingly, many of the solutions to the many problems I had to solve came from my knowledge of Munros and Gaelic. AI sometimes provided the code but it's a nice reminder it can only provide the answers to questions you know to ask.\n\n\nThe reason I wanted to use walkhighlands data is that it has a bunch of route information that I could use for exploration that wasn't contained in the Database of British and Irish Hills that is the base of the Tidy Tuesday data:\n\n-   Region\n-   Estimated length of walk in hours\n-   Distance of walk\n-   Total ascent  of route (not just of each individual Munro)\n-   Route descriptions\n-   User rating of each Munro\n-   Number of ascents recorded for each Munro\n\nI contacted walkhighlands to ask permission to share what I've done and they said yes because they're lovely. I've still decided not to include the code I used for web scraping so I don't inadvertently cause them any issues and so I'll just describe roughly what I did instead.\n\nThe approach was to first scrape walkhighlands for the list of Munros, the region in which they are located, and their height from the [Munro A-Z page](https://www.walkhighlands.co.uk/munros/munros-a-z). Then it took one route for each munro (the first listed), the min and max estimated walk time, distance in km, total ascent in metres, and used regex to look for certain words that describe walk features that might be of interest (scramble, exposed, arete, river, spate, bog). walkhighlands also provides a Grade rating for each walk as well as a bog factor, however, these are represented as images, and try as I (well, AI) might, I could not get it to parse this information.\n\n![](wh_grade.png)\n\nAn important note for those of you who are familiar with walkhighlands, as highlighted, I included one route per munro - the first one listed. This can make a big difference to the walk, for example, which route you take up Ben Nevis significantly changes the fear factor and technicality. Text mining is also a blunt tool and only looks at whether a word is contained in the walk report rather than its context -  a route that reads \"there is no scrambling required\" would still have been included in the \"scramble\" category and exposure can relate to the weather or heights.\n\nIt took a long time to get the AI to provide code that worked and there were a number of issues - at one point it was matching the route to the wrong Munro, then it didn't return all Munros, then it was missing a bunch of routes. I had to manually create a file of some routes to load in because I could not find a solution as to why these handful were failing. Because I  could not have done any of this type of scraping without AI, I really have no idea why it works and why it didn't. This is intellectually unsatisfying but also, the idea you'd be willing to trust this black box of \"knowledge\" to something more serious than an obsessive deep dive into your favorite mountains is madness.\n\nHere's what the walkhighlands data looks like.\n\n```{r echo = FALSE, message = FALSE,warning = FALSE }\n\nlibrary(tidyverse)\nlibrary(flextable)\n\nwalkhighlands <- read_csv(\"walkhighlands.csv\")\n\nhead(walkhighlands, 2) |>\n  flextable()|>\n  autofit()\n```\n\n\n## Database of British and Irish Hills\n\nNext it was time to load in the Tidy Tuesday dataset which is from the Database of British and Irish Hills. In order to be able to join this with my walkhighlands database, I had to do quite a lot of wrangling although thankfully I was not reliant on AI and mainly able to achieve it because of my existing knowledge of Munros and Gaelic. \n\nI wasn't that bothered about the Munro status changes over the years as the walkhighlands database allowed me to do other more interesting analyses so I dropped these bits.\n\n\n```{r message = FALSE,warning = FALSE }\nlibrary(tidyverse)\nlibrary(fuzzyjoin)\nlibrary(ggthemes)\nlibrary(ggridges)\nlibrary(flextable)\nlibrary(stringi)\nlibrary(tidytext)\nlibrary(sf)       \nlibrary(plotly)\nlibrary(rnaturalearth)\n\nscottish_munros <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-08-19/scottish_munros.csv')\n\nraw_data <- read_csv(\"https://www.hills-database.co.uk/munrotab_v8.0.1.csv\")\n\nscottish_munros <- raw_data |>\n  filter(`2021` == \"MUN\") |>\n  select(\n    `DoBIH Number`, Name,\n    `Height (m)`, xcoord, ycoord, \"Grid Ref\",\n  ) |>\n  drop_na(`DoBIH Number`) |> \n  rename(\n    munro = \"Name\",\n    height = `Height (m)`,\n    number = `DoBIH Number`,\n    grid_ref = \"Grid Ref\"\n  ) \nrm(raw_data)\n```\n\n## What's in a name (issues)\n\nThe first problem to solve before trying to join the two datasets was that some of the names of the Munros differ between the two - sometimes this is because there are variants in the Gaelic (Carn Eighe/Càrn Eige), sometimes the Anglicised version is used, and sometimes it's because multiple Munros have the same name so they have additional information added in parenthesis in one of the files (Stuc an Lochain [Stuchd an Lochain]/Stùcd an Lochain).\n\n```{r}\nscottish_munros <- scottish_munros |>\n  # Standardise names in the 'dobih' dataset to Walkhighlands spellings\n  mutate(\n    munro = case_when(\n      munro == \"A' Chraileag [A' Chralaig]\" ~ \"A' Chralaig\",\n      munro == \"Beinn Challuim [Ben Challum]\" ~ \"Ben Challum\",\n      munro == \"Beinn Sheasgarnaich [Beinn Heasgarnich]\" ~ \"Beinn Heasgarnich\",\n      munro == \"Beinn a' Bhuird North Top\" ~ \"Beinn a' Bhùird\",\n      munro == \"Ben Klibreck - Meall nan Con\" ~ \"Ben Klibreck\",\n      munro == \"Blabheinn [Bla Bheinn]\" ~ \"Blà Bheinn\",\n      munro == \"Cac Carn Beag (Lochnagar)\" ~ \"Lochnagar\",\n      munro == \"Carn Eighe\" ~ \"Càrn Eige\",\n      munro == \"Carn a' Choire Bhoidheach\" ~ \"Càrn a' Choire Bhòidheach\",\n      munro == \"Creag a' Mhaim\" ~ \"Creag a'Mhàim\",\n      munro == \"Glas Leathad Mor (Ben Wyvis)\" ~ \"Ben Wyvis\",\n      munro == \"Leabaidh an Daimh Bhuidhe (Ben Avon)\" ~ \"Ben Avon\",\n      munro == \"Meall Garbh\" ~ \"Meall Garbh (Ben Lawers)\",\n      munro == \"Meall na Aighean\" ~ \"Creag Mhòr (Meall na Aighean)\",\n      munro == \"Sgurr Dearg - Inaccessible Pinnacle\" ~ \"Inaccessible Pinnacle\",\n      munro == \"Sgurr Mhor (Beinn Alligin)\" ~ \"Sgùrr Mòr (Beinn Alligin)\",\n      munro == \"Sgurr na h-Ulaidh [Sgor na h-Ulaidh]\" ~ \"Sgòr na h-Ulaidh\",\n      munro == \"Sgurr nan Ceathramhnan [Sgurr nan Ceathreamhnan]\" ~ \"Sgùrr nan Ceathreamhnan\",\n      munro == \"Stob Coir' an Albannaich\" ~ \"Stob Coir an Albannaich\",\n      munro == \"Stuc an Lochain [Stuchd an Lochain]\" ~ \"Stùcd an Lochain\",\n      munro == \"Càrn nan Gobhar (Strathfarrar)\" ~ \"Càrn nan Gobhar (Loch Mullardoch)\",\n      TRUE ~ munro\n    )\n  )\n```\n\nAfter standardising the names, to facilitate the join I also had to convert to lower case, remove accents (whether they're used differs between the datasets), and any parenthesis information from the Munro names. \n\nAfter this cleaning, because multiple Munros have the same name, I needed to join on height to distinguish them as thankfully, there aren't two Munros with the same name and height. However, a problem I wasn't anticipating is that height measurements differed between the datasets. A lot of these can be put down to rounding - walkhighlands uses whole numbers whilst the DoBIH uses two decimal places. However, this doesn't explain them all (the largest difference is 8.1 metres, that's a lot!). I don't know which one is \"correct\" or why they differ but given DoBIH is numerically more precise, I decided to use that as my measure of height in any analysis.\n\nMy AI-fuelled discovery was `fuzzyjoin` which allows you to set a tolerance level for the join and pick a best match. I've never needed this before but it provided itself to be extremely useful - with a bit of trial and error I set a tolerance of 10m and manually checked the output to ensure everything had lined up correctly.\n\n**UPDATE**: Because walkhighlands are great (honestly go and give them some money), they have updated the heights based on the DoBIH data so they now match (is this impact?).\n\n```{r}\n\n# 0) Choose a tolerance in metres (use Inf if you want “nearest regardless”)\ntol_m <- 10\n\n# 1) Normalise names in BOTH tables: remove (...) and [...], drop accents, lower-case, squish\nx <- walkhighlands %>%\n  mutate(\n    munro_key = munro %>%\n      str_replace_all(\"\\\\s*\\\\([^)]*\\\\)\", \"\") %>%   # remove text in ( )\n      str_replace_all(\"\\\\s*\\\\[[^\\\\]]*\\\\]\", \"\") %>% # remove text in [ ]\n      stri_trans_general(\"Latin-ASCII\") %>%\n      str_to_lower() %>%\n      str_squish(),\n    height = parse_number(as.character(height)),\n    row_id_x = row_number()\n  )\n\ny <- scottish_munros %>%\n  mutate(\n    munro_key = munro %>%\n      str_replace_all(\"\\\\s*\\\\([^)]*\\\\)\", \"\") %>%\n      str_replace_all(\"\\\\s*\\\\[[^\\\\]]*\\\\]\", \"\") %>%\n      stri_trans_general(\"Latin-ASCII\") %>%\n      str_to_lower() %>%\n      str_squish(),\n    height = parse_number(as.character(height)),\n    row_id_y = row_number()\n  )\n\n# 2) Fuzzy FULL join on exact munro_key + height within tolerance\ncandidates <- fuzzy_full_join(\n  x, y,\n  by = c(\"munro_key\" = \"munro_key\", \"height\" = \"height\"),\n  match_fun = list(`==`, function(a, b) abs(a - b) <= tol_m)\n) %>%\n  # standardise suffixes for older fuzzyjoin that uses .x/.y\n  rename_with(~ str_replace(.x, \"\\\\.x$\", \"_wh\")) %>%\n  rename_with(~ str_replace(.x, \"\\\\.y$\", \"_dobih\")) %>%\n  mutate(\n    height_diff = abs(height_wh - height_dobih),\n    height_diff = if_else(is.na(height_diff), Inf, height_diff)\n  )\n\n# 3) Reduce to one nearest match per row on each side, preserving FULL-join behaviour\nbest_for_left  <- candidates %>% \n  group_by(row_id_x) %>% \n  slice_min(height_diff, with_ties = FALSE) %>% \n  ungroup()\nbest_for_right <- candidates %>% \n  group_by(row_id_y) %>% \n  slice_min(height_diff, with_ties = FALSE) %>% \n  ungroup()\n\nmunro_dat <- bind_rows(best_for_left, best_for_right) %>%\n  distinct(row_id_x, row_id_y, .keep_all = TRUE) %>%\n  mutate(\n    site_key = coalesce(grid_ref, paste0(xcoord, \"_\", ycoord)),\n    munro_wh_clean = str_replace(munro_wh, \"\\\\s*\\\\([^)]*\\\\)$\", \"\")  # drop \"(Loch Mullardoch)\" etc.\n  ) %>%\n  group_by(site_key) %>%\n  slice_min(height_diff, with_ties = FALSE) %>%   # keep the single closest pair for that site\n  ungroup() %>%\n  mutate(munro_wh = munro_wh_clean) %>%\n  select(-munro_wh_clean) |>\n  mutate(time = (time_hours_min + time_hours_max) / 2) |>\n  select(-munro_dobih,-munro_key_dobih) |>\n  rename(munro = munro_wh)|>\n  mutate(scramble_exposed = case_when(\n    scramble & exposed ~ \"Both\",\n    scramble & !exposed ~ \"Scramble\",\n    !scramble & exposed ~ \"Exposed\",\n    TRUE ~ \"Neither\"\n  )) |>\n  mutate(scramble_exposed = factor(scramble_exposed,\n                                   levels = c(\"Neither\", \"Scramble\", \"Exposed\", \"Both\"))) |>\n    mutate(wet = case_when(\n    spate & bog ~ \"Both\",\n    spate & !bog ~ \"Large river\",\n    !spate & bog ~ \"Boggy\",\n    TRUE ~ \"Neither\"\n  )) |>\n  mutate(wet = factor(wet,\n                                   levels = c(\"Neither\", \"Large river\", \"Boggy\", \"Both\")))\n\n\n\nrm(x,y, best_for_left, best_for_right, candidates, tol_m, walkhighlands, scottish_munros)\n```\n\nI also created some manual colour scales on a nature theme:\n\n```{r}\n\nnature_6 <- c(\n  \"#355E3B\",  \n  \"#4B4F58\",  \n  \"#4682B4\",  \n  \"#8E6C88\",  \n  \"#E07B39\",\n  \"#BDB76B\"\n)\n\nnature_5 <- c(\n  \"#355E3B\",  \n  \"#4B4F58\",  \n  \"#4682B4\",  \n  \"#E07B39\",\n  \"#BDB76B\"\n)\n\nnature_4 <- c(\n  \"#355E3B\",  \n  \"#4B4F58\",  \n  \"#4682B4\",  \n  \"#E07B39\"   \n)\n\nnature_13 <- c(\n  \"#355E3B\",  # Pine green\n  \"#6B8E23\",  # Moss\n  \"#BDB76B\",  # Dry grass\n  \"#8B5A2B\",  # Earth brown\n  \"#D2B48C\",  # Sand\n  \"#87CEEB\",  # Sky blue\n  \"#4682B4\",  # Loch blue\n  \"#191970\",  # Mountain shadow (midnight blue)\n  \"#7D7D7D\",  # Granite grey\n  \"#A9A9A9\",  # Slate grey\n  \"#8E6C88\",  # Heather purple\n  \"#E07B39\",  # Sunset orange\n  \"#FFD700\"   # Sun yellow\n)\n```\n\n## Routes vs Munros\n\nFor some of the analyses later on, it makes more sense to do the analysis by route rather than by individual mountains - one route can have multiple Munros and the time, distance, and total ascent is for the entire route, not individually.\n\nThere are 282 Munros, but these are covered by 152 walkhighlands routes.\n\nBecause the user ratings and number of ascents are done by individual Munro rather than route, I also had to calculate the average for these for the route. It won't be completely accurate because you don't have to climb all the Munros on a given route, but given that I am just dicking about on the internet, that's probably fine.\n\n```{r}\nroute_dat <-munro_dat |>\n  select(first_route_url, first_route_title,\n         region, time_hours_min:deer_fence, time, scramble_exposed, wet) |>\n  unique()\n\nroute_stats <- munro_dat |>\n  group_by(first_route_url) |>\n  summarise(route_rating = janitor::round_half_up(mean(rating), 2),\n            route_ascents = janitor::round_half_up(mean(ascents),0 ))\n\nroute_dat <- route_dat |>\n  left_join(route_stats)\n\n```\n\n## Scrambling and exposure\n\nI have a reasonably bad fear of heights so anything that mentions scrambling or exposure worries me. First question, are higher munros scarier?\n\nBig thank you to [Jessica Moore](https://bsky.app/profile/jessimoore.bsky.social/post/3lwxw4fw5ys23) for the inspiration for this one.\n\n```{r}\nggplot(munro_dat, \n       aes(height_dobih, scramble_exposed, fill = scramble_exposed)) +\n  geom_density_ridges(quantile_lines = TRUE, quantile_fun = mean,\n                      vline_linetype = \"dashed\",\n                      aes(color = \"Mean height (m)\")) +\n  scale_y_discrete(expand = c(0.01, 0)) +\n  scale_x_continuous(expand = c(0.01, 0)) +\n  scale_color_manual(values = c(\"Mean height (m)\" = \"black\")) +\n  theme_economist() +\n  scale_fill_manual(values = nature_4) +  \n  labs(x = NULL, y = NULL,\n       title = \"Are higher Munros scarier?\",\n       colour = NULL,\n       subtitle = \"Routes descriptions that mention exposure tend to be on higher Munros\")+\n  guides(fill = \"none\") +\n  theme(legend.position = \"bottom\",\n        legend.position.inside = c(0.8,0.10))\n```\n\nFor locating the scary munros, I decided that an interactive plotly map was called for so that you can easily isolate the different types - these work much better on a full browser than a phone.\n\nHave I mentioned that I dislike heights and exposure?\n\n```{r}\nmunros_map <- munro_dat %>%\n  select(munro, region, xcoord, ycoord, height_dobih, scramble_exposed, wet, toilet, pub, bothy, deer_fence, car_park, wood) %>%\n  na.omit()\n\n# Convert OSGB36 coordinates to sf object\nmunros_sf <- munros_map %>%\n  st_as_sf(coords = c(\"xcoord\", \"ycoord\"), \n           crs = 27700)  # EPSG:27700 is OSGB36 / British National Grid\n\n# Transform to WGS84 (lat/long) for easier plotting\nmunros_lat_long <- munros_sf %>%\n  st_transform(crs = 4326)\n\n# Extract coordinates for ggplot\nmunros_coords <- munros_lat_long %>%\n  mutate(\n    longitude = st_coordinates(.)[,1],\n    latitude = st_coordinates(.)[,2]\n  ) %>%\n  st_drop_geometry() %>%\n  arrange(-height_dobih)\n\n\nuk_map <- rnaturalearth::ne_countries(scale = \"large\", \n                                  country = \"United Kingdom\", \n                                    returnclass = \"sf\")\n\n# Step 2: Specify shape codes (16 = circle, 17 = triangle, etc.)\nshape_values <- c(\n  \"Neither\" = 16,    # filled circle\n  \"Scramble\" = 17,   # filled triangle\n  \"Exposed\" = 15,    # filled square\n  \"Both\" = 18        # filled diamond\n)\n\np <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56.5, 58.6)) +\n  geom_jitter(data = munros_coords, \n             aes(x = longitude, \n                 y = latitude, \n                 shape = scramble_exposed, \n                 colour = scramble_exposed,\n                 text = munro), \n             size = 1,\n             height = .05,\n             width = .05) + \n  scale_x_continuous(breaks = NULL) +\n  scale_shape_manual(values = shape_values) +\n  scale_y_continuous(breaks = NULL) +\n  scale_colour_manual(values = nature_4) +\n  labs(title = \"Where are the scary Munros?\",\n       subtitle = \"Walk descriptions that reference:\",\n       colour = \"Route mentions\", shape = \"Route mentions\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(p, tooltip = \"text\")\n```\n\n## By region\n\nI also thought it would be fun to look into regional differences. The munros vary massively in character depending on where you are in the country (you can imagine hobbits living in Cairngorms whilst Skye would be home to dragons), but how is this reflected in the walk features?\n\n### Regional map\n\nWhich Munros are in which region is taken from the [walkhighlands A-Z](https://www.walkhighlands.co.uk/munros/munros-a-z) but I've had a few people ask since posting this, so here's an easy to read map.\n\n```{r}\np3 <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56.5, 58.6)) +\n  geom_jitter(data = munros_coords, \n             aes(x = longitude, \n                 y = latitude, \n                 colour = region,\n                 text = munro), \n             size = 1,\n             height = .05,\n             width = .05) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  scale_colour_manual(values = nature_13) +\n  labs(title = \"Munros by region\",\n       colour = NULL) +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(p3, tooltip = \"text\")\n```\n\nAnd here's the counts for how many Munros and routes are in each region. It's highly correlated, but the ranks do change a little.\n\n```{r}\nmunro_region <- munro_dat |>\n  count(region, sort = TRUE) |>\n  rename(\"munros\" = \"n\") \n\nroute_region <- route_dat |>\n  count(region, sort = TRUE) |>\n  rename(\"routes\" = \"n\")\n\ninner_join(munro_region, route_region) |>\n  flextable()|>\n  autofit()\n```\n\n### Tallest Munros\n\nWhich region has the tallest Munros?\n\n```{r}\n\nregion_height <- munro_dat |>\n  group_by(region) |>\n  summarise(avg_height = mean(height_dobih, na.rm = TRUE), .groups = \"drop\") |>\n  slice_max(avg_height, n = 5)\n\nggplot(\n  semi_join(munro_dat, region_height, by = \"region\"),\n  aes(\n    x = height_dobih,\n    y = fct_reorder(region, height_dobih, .fun = mean, .desc = FALSE),\n    fill = region\n  )\n)  +\n  geom_density_ridges(\n    quantile_lines = TRUE, quantile_fun = mean,\n    vline_linetype = \"dashed\",\n    aes(colour = \"Mean height (m)\")\n  ) +\n  scale_y_discrete(expand = c(0.01, 0)) +\n  scale_x_continuous(expand = c(0.01, 0)) +\n  scale_colour_manual(values = c(\"Mean height (m)\" = \"black\")) +\n  theme_economist() +\n  scale_fill_manual(values = nature_5) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Which region has the highest Munros?\",\n    colour = NULL,\n    subtitle = \"Top 5 regions displayed. On average, Loch Ness has the highest Munros\"\n  ) +\n  guides(fill = \"none\") +\n  theme(\n    legend.position = \"inside\",\n   legend.position.inside = c(0.8, 0.1),\n    legend.text = element_text(size = 10)\n  )\n```\n\nAnd fere's the full list in table form:\n\n```{r}\nmunro_dat |>\n  group_by(region) |>\n  summarise(avg_height = mean(height_dobih, na.rm = TRUE), .groups = \"drop\") |>\n  arrange(desc(avg_height)) |>\n  flextable() |>\n  colformat_double(digits = 0)|>\n  autofit()\n```\n\n### Longest routes\n\nWhich region has the longest routes on average by distance?\n\nThis plot uses the route data although I am pleased that the order remains the same if you use the munro data (because I only realised I should do it by route after I shared this publicly).\n\n```{r}\n\n# Top 5 regions by mean distance\nregion_distance <- route_dat |>\n  group_by(region) |>\n  summarise(avg_distance = mean(distance_km, na.rm = TRUE), .groups = \"drop\") |>\n  slice_max(avg_distance, n = 5)\n\n# Keep only those regions in the raw data\ntop_dat <- semi_join(route_dat, region_distance, by = \"region\")\n\n\nggplot(\n  top_dat,\n  aes(\n    x = distance_km,  # use the per-route variable here\n    y = fct_reorder(region, distance_km, .fun = mean, .desc = FALSE),\n    fill = region\n  )\n) +\n  geom_density_ridges(\n    quantile_lines = TRUE, quantile_fun = mean,\n    vline_linetype = \"dashed\",\n    aes(colour = \"Mean distance (km)\")\n  ) +\n  scale_y_discrete(expand = c(0.01, 0)) +\n  scale_x_continuous(expand = c(0.01, 0)) +\n  scale_colour_manual(values = c(\"Mean distance (km)\" = \"black\")) +\n  theme_economist() +\n  scale_fill_manual(values = nature_5) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Which region has the longest walks?\",\n    colour = NULL,\n    subtitle = \"Top 5 regions displayed. On average, Loch Ness has the longest walks\"\n  ) +\n  guides(fill = \"none\") +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(0.82, .1),\n    legend.text = element_text(size = 10)\n    )\n```\n\nAnd here's the full list in table form:\n\n```{r}\nroute_dat |>\n  group_by(region) |>\n  summarise(avg_distance = mean(distance_km, na.rm = TRUE), .groups = \"drop\") |>\n  arrange(desc(avg_distance)) |>\n  flextable() |>\n  colformat_double(digits = 2)|>\n  autofit()\n```\n\n### Most ascent\n\nWhich region has the most ascent per route?\n\nAgain the order doesn't change if you use routes or Munros as the data (the exact values do slightly but not the rank).\n\n```{r}\n# Top 5 regions by mean distance\nregion_ascent <- munro_dat |>\n  group_by(region) |>\n  summarise(avg_ascent = mean(ascent, na.rm = TRUE), .groups = \"drop\") |>\n  slice_max(avg_ascent, n = 5)\n\n# Keep only those regions in the raw data\ntop_ascent <- semi_join(munro_dat, region_ascent, by = \"region\")\n\n\nggplot(\n  top_ascent,\n  aes(\n    x = ascent,  # use the per-route variable here\n    y = fct_reorder(region, ascent, .fun = mean, .desc = FALSE),\n    fill = region\n  )\n) +\n  geom_density_ridges(\n    quantile_lines = TRUE, quantile_fun = mean,\n    vline_linetype = \"dashed\",\n    aes(colour = \"Mean ascent (m)\")\n  ) +\n  scale_y_discrete(expand = c(0.01, 0)) +\n  scale_x_continuous(expand = c(0.01, 0)) +\n  scale_colour_manual(values = c(\"Mean ascent (m)\" = \"black\")) +\n  theme_economist() +\n  scale_fill_manual(values = nature_5) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Which region has the most ascent?\",\n    colour = NULL,\n    subtitle = \"Top 5 regions displayed. On average, Loch Ness has the most ascent\"\n  ) +\n  guides(fill = \"none\") +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(0.82, .1),\n    legend.text = element_text(size = 10)  \n    )\n```\n\nAnd here's the full list in table form:\n\n```{r}\nroute_dat |>\n  group_by(region) |>\n  summarise(avg_ascent = mean(ascent, na.rm = TRUE), .groups = \"drop\") |>\n  arrange(desc(avg_ascent)) |>\n  flextable() |>\n  colformat_double(digits = 0)|>\n  autofit()\n```\n\n### Munros per route\n\nWhere do you get the most bang for your buck? \n\n```{r}\n\nmunro_dat |>\n  count(region, first_route_title, name = \"n\") |>\n  group_by(region) |>\n  summarise(avg_count = mean(n), .groups = \"drop\") |>\n  ggplot(aes(\n    x = fct_reorder(region, avg_count),\n    y = avg_count,\n    fill = region\n  )) +\n  geom_col() +\n  scale_fill_manual(values = nature_13) +\n  coord_flip() +\n  guides(fill = \"none\") +\n  labs(x = NULL, y = \"Number of Munros\",\n       title = \"Average number of Munros bagged per route\") +\n  theme_economist()\n```\n\n### User ratings\n\nWhich region has the highest and lowest rated Munros (by user rating)?\n\n```{r}\nregion_rating_top <- munro_dat |>\n  group_by(region) |>\n  summarise(avg_rating = mean(rating, na.rm = TRUE), \n            n = n(),\n            .groups = \"drop\") |>\n  filter(n >= 5)|>\n  slice_max(avg_rating, n = 3)\n\n# bottom 3\n\nregion_rating_bottom <- munro_dat |>\n  group_by(region) |>\n  summarise(avg_rating = mean(rating, na.rm = TRUE), \n            n = n(),\n            .groups = \"drop\") |>\n  filter(n >= 5)|>\n  slice_min(avg_rating, n = 3)\n\nregion_top_bottom <-bind_rows(region_rating_top, region_rating_bottom)\n\nggplot(\n  semi_join(munro_dat, region_top_bottom, by = \"region\"),\n  aes(\n    x = rating,\n    y = fct_reorder(region, rating, .fun = mean, .desc = FALSE),\n    fill = region\n  )\n)  +\n  geom_density_ridges(\n    quantile_lines = TRUE, quantile_fun = mean,\n    vline_linetype = \"dashed\",\n    aes(colour = \"Mean height (m)\")\n  ) +\n  scale_y_discrete(expand = c(0.01, 0)) +\n  scale_x_continuous(expand = c(0.01, 0)) +\n  scale_colour_manual(values = c(\"Mean height (m)\" = \"black\")) +\n  theme_economist() +\n  scale_fill_manual(values = nature_6) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Which region has the highest user rated Munros?\",\n    colour = NULL,\n    subtitle = \"Top & bottom 3 (regions w/ 5+ Munros)\"\n  ) +\n  guides(fill = \"none\") +\n  theme(\n    legend.position = \"inside\",\n   legend.position.inside = c(0.87, 0.1),\n    legend.text = element_text(size = 10)\n  )\n\n```\n\nAnd here's the full list in table form:\n\n```{r}\nmunro_dat |>\n  group_by(region) |>\n  summarise(avg_rating = mean(rating, na.rm = TRUE), \n            \"no. munros\" = n(),.groups = \"drop\") |>\n  arrange(desc(avg_rating)) |>\n  flextable() |>\n  colformat_double(digits = 2)|>\n  autofit()\n```\n\n### Ascents by rating\n\nNumber of ascents (how many people have recorded on walkhighlands that they have summitted a particular Munro) by ratings\n\n```{r}\nggplot(route_dat, aes(x = route_ascents, y = route_rating)) +\n  geom_point(aes(text = first_route_url)) +\n  theme_economist() +\n  scale_y_continuous(breaks = seq(1:5)) +\n  coord_cartesian(ylim = c(1,5)) +\n  labs(y = \"User rating (1-5)\",\n       x = \"Number of recorded ascents\",\n       title = \"Number of ascents by rating\")+\n  annotate(geom = \"curve\", \n          x = 31000, y = 3, \n          xend = 31800, yend = 3.75,\n          curvature = 0.3,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 31000, y = 2.8,\n           label = \"Ben Lomond\")+\n  annotate(geom = \"curve\", \n          x = 23000, y = 1.45, \n          xend = 18900, yend = 2.30,\n          curvature = -0.3,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 28000, y = 1.45,\n           label = \"The Cairnwell Munros\") +\n  annotate(geom = \"curve\", \n          x = 5559, y = 1.5, \n          xend = 5559, yend = 4.61,\n          curvature = -0.55,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 7600, y = 1.35,\n           label = \"Sgùrr nan Gillean\")\n\n\n\n\n```\n\nAnd then as an interactive plot:\n\n```{r}\np5 <- ggplot(route_dat, aes(x = route_ascents, y = route_rating)) +\n  geom_point(aes(text = first_route_title)) +\n  theme_economist() +\n  scale_y_continuous(breaks = seq(1:5)) +\n  coord_cartesian(ylim = c(1,5)) +\n  labs(y = \"User rating (1-5)\",\n       x = \"Number of recorded ascents\",\n       title = \"Number of ascents per route by rating\")\n\nggplotly(p5)\n```\n\n## Ascent (m)\n\nAs you would expect, total ascent correlates strongly with total time, but there are some points of interest. Bidein a' Choire Sheasgaich and Lurg Mhòr have the longest estimated walk time but their remoteness means that they're an outlier in terms of the amount of ascent you'd expect for that time. The Fisherfield 6 claim the prize for most ascent by some distance but are bang on in terms of the ascent/time relationship. Meall Buidhe wins the award for being the quickest munro to bag, with the least ascent.\n\n\n```{r}\nggplot(route_dat, aes(x = ascent, y = time)) +\n  geom_jitter(height = .05, width = .05) +\n  scale_x_continuous(breaks = seq(500, 2500, 250)) +\n  scale_y_continuous(breaks = seq(0, 20, 2)) +\n  annotate(geom = \"curve\", \n          x = 1200, y = 15, \n          xend = 1450, yend = 16,\n          curvature = -0.3,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 1150, y = 14.5,\n           label = \"Bidein a' Choire Sheasgaich\\nand Lurg Mhòr\") +\n    annotate(geom = \"curve\", \n          x = 2050, y = 13.5, \n          xend = 2220, yend = 15,\n          curvature = -0.3,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 2100, y = 13,\n           label = \"Fisherfield 6\")+\n    annotate(geom = \"curve\", \n          xend = 575, yend = 2.9, \n          x = 1250, y = 4,\n          curvature = 0.2,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 1450, y = 4.5,\n           label = \"Meall Buidhe\")+\n  theme_economist()  +\n  labs(x = \"Ascent (m)\", \n       y = \"Time (hours)\",\n       title = \"Total ascent by time\") +\n    theme(legend.position = \"inside\",\n    axis.title.x = element_text(margin = margin(t = 8)),\n    axis.title.y = element_text(margin = margin(r = 8)),\n    legend.position.inside = c(0.9, .2),\n    legend.text = element_text(size = 10)  \n  )\n```\n\n\nAnd here's an interactive version of that plot that adds in scrambling and exposure because had I mentioned, I am scared of heights. \n\n```{r}\np1 <- ggplot(route_dat, aes(x = ascent, y = time)) +\n  geom_jitter(aes(shape = scramble_exposed, \n                 colour = scramble_exposed,\n                 text = first_route_title), \n             size = 1) +\n  scale_x_continuous(breaks = seq(500,2500, 250)) +\n  scale_y_continuous(breaks = seq(0,20,2)) +\n  scale_shape_manual(values = shape_values) +\n  scale_colour_manual(values= nature_4) +\n  labs(x = \"Ascent (m)\", \n       y = \"Time (hours)\",\n       title = \"Ascent by time\",\n       shape = \"Route mentions\",\n       colour = \"Route mentions\") +\n  theme_economist() +\n  theme(\n    axis.title.x = element_text(margin = margin(t = 8)),\n    axis.title.y = element_text(margin = margin(r = 8)),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(p1, tooltip = \"text\")\n\n```\n\n## Where's wet?\n\nIf the text-mining for scrambling and exposure is a blunt tool then my approach here is even blunter. There are multiple words I could have searched for regarding the presence of water - river, stream, burn - but many of those represent features that don't make a difference to the walk if they present no difficulty (\"cross the bridge over the river\"). I decided to use the word \"spate\" because when the river is large, walkhighlands often highlights that it would be difficult or impossible to cross \"in spate\". \n\nSo these aren't all the rivers, just ones where the description indicates crossing them might present an issue.\n\n```{r}\n\nshape_values <- c(\n  \"Neither\" = 16,    # filled circle\n  \"River\" = 17,   # filled triangle\n  \"Boggy\" = 15,    # filled square\n  \"Both\" = 18        # filled diamond\n)\n\np2 <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56.5, 58.6)) +\n  geom_jitter(data = munros_coords, \n             aes(x = longitude, \n                 y = latitude, \n                 shape = wet, \n                 colour = wet,\n                 text = munro), \n             size = 1,\n             height = .05,\n             width = .05) + \n  scale_x_continuous(breaks = NULL) +\n  scale_shape_manual(values = shape_values) +\n  scale_y_continuous(breaks = NULL) +\n  scale_colour_manual(values = nature_4) +\n  guides(shape = \"none\") +\n  labs(title = \"Where is wet?\\n(Everywhere, it's Scotland)\",\n              subtitle = \"Walk descriptions that reference:\",\n       colour = \"Route mentions\", shape = \"Route mentions\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(p2, tooltip = \"text\")\n```\n\n## Woodland\n\nI've been fortunate enough to go hiking in Switzerland and Albania this year and it has did highlight to me how bare the Munros often are, thanks to destrctuive logging and farming practices.\n\n```{r}\nwood_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, wood == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 text = munro, colour = \"#355E3B\"), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention woodland\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(wood_plot, tooltip = \"text\")\n```\n\n\n```{r}\nmunro_dat |>\n  count(region, wood) |>\n  group_by(region) |>\n  mutate(percent = janitor::round_half_up(n/sum(n)*100,0)) |>\n  filter(wood == TRUE) |>\n  ungroup() |>\n  arrange(desc(percent)) |>\n  select(-wood, -n) |>\n  flextable() |>\n  set_caption(caption = \"Percent of routes that mention woodland\")\n\n# 10 greens for manual scales (light → dark)\ngreens_10 <- grDevices::colorRampPalette(\n  c(\"#00441b\", \"#006d2c\", \"#238b45\", \"#41ab5d\", \"#74c476\")\n)(10)\n\n\nmunro_dat |>\n  count(region, wood) |>\n  group_by(region) |>\n  mutate(percent = janitor::round_half_up(n / sum(n) * 100, 0)) |>\n  filter(wood) |>\n  ungroup() |>\n  mutate(region = forcats::fct_reorder(region, percent, .desc = FALSE)) |>\n  ggplot(aes(x = region, y = percent, fill = region)) +\n  geom_col() +\n  scale_fill_manual(values = rev(greens_10)) +\n  guides(fill = \"none\") +\n  coord_flip() +\n  scale_y_continuous(breaks = seq(0, 100, 10)) +\n  theme_economist() +\n  labs(x = NULL, y = NULL,\n       title = \"Percent of routes that mention woodland by region\")\n\n```\n\n\n\n\n## Non-natural features\n\nWith the usual caveats about the limits of text mining, here's some maps showing route descriptions that mention non-natural features (bothy, deer fence (because they're scary), pub, toilet). Some of these are more useful than others. \n\n### Bothy\n\n```{r}\nbothy_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, bothy == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 colour = bothy,\n                 text = munro), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention a bothy\") +\n  guides(colour = \"none\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(bothy_plot, tooltip = \"text\")\n```\n\n### Deer fences\n\nI really hate deer fences. \n\n```{r}\nfence_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, deer_fence == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 colour = deer_fence,\n                 text = munro), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention a deer fence\") +\n  guides(colour = \"none\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(fence_plot, tooltip = \"text\")\n```\n\n### Toilets\n\nWhat I learned making this plot is that I cannot spell toilet. I lost an hour of my life to realising the error was coming from \"toliet\". \n\n```{r}\n\ntoilet_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, toilet == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 colour = toilet,\n                 text = munro), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention a toilet\") +\n  guides(colour = \"none\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(toilet_plot, tooltip = \"text\")\n```\n\n### Pubs\n\nThis one wasn't really worth doing given how few routes mention a pub, but for Sandie, anything. \n\n```{r}\npub_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, pub == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 colour = pub,\n                 text = munro), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention a pub\") +\n  guides(colour = \"none\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(pub_plot, tooltip = \"text\")\n```\n\n\n### Car parks\n\n```{r}\ncar_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, car_park == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 colour = pub,\n                 text = munro), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention a car park\") +\n  guides(colour = \"none\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(car_plot, tooltip = \"text\")\n```\n\n\n## Best and worst Munros\n\nI was asked by [Kate Gilliver](https://bsky.app/profile/penarthkate.bsky.social) via Bluesky \"which Munro is the ultimate combination of high, exposed, scary, remote, boggy, rivery and generally to be avoided?\"\n\nSo with the following criteria:\n\n- Doesn't mention bog, river, scramble, exposed, or a deer fence\n- Takes 6 hours or less\n\nYour top 5 choices by user rating are.....\n\n```{r}\nroute_dat |>\n  filter(bog == FALSE,\n         river == FALSE,\n         scramble == FALSE,\n         exposed == FALSE,\n         deer_fence == FALSE,\n         time <= 6) |>\n  arrange(desc(route_rating)) |>\n  select(route = first_route_title, region, route_rating) |>\n  slice(1:5) |>\n  flextable()|>\n  autofit()\n```\n\n\nIf you want a scary but dry hike:\n\n- No bog or river\n- But scramble and exposed\n- Top 5 by user rating\n\n```{r}\nroute_dat |>\n  filter(bog == FALSE,\n         river == FALSE,\n         scramble == TRUE,\n         exposed == TRUE) |>\n  arrange(desc(route_rating)) |>\n  select(route = first_route_title, region, route_rating) |>\n  slice(1:5) |>\n  flextable()|>\n  autofit()\n```\n\n\nAnd if you want to hate yourself:\n\n- Bog and river\n- More than 6 hours\n- More than 1000 metres of ascent\n- Lowest rated by users\n\n```{r}\nroute_dat |>\n  filter(bog == TRUE,\n         river == TRUE,\n         time >6,\n         ascent > 1000) |>\n  arrange(route_rating) |>\n  select(route = first_route_title, region, route_rating) |>\n  slice(1:5) |>\n  flextable()|>\n  autofit()\n```\n\n\nI may have become a bit obsessed.\n\nI must stop.\n\nBut if you have any other suggestions for analysis....just ask.","srcMarkdownNoYaml":"\n\n\nI was immediately obsessed when I saw the Tidy Tuesday theme was [Scottish Munros](https://github.com/rfordatascience/tidytuesday/blob/main/data/2025/2025-08-19/readme.md) - we have climbed 58/282 so far. As I assume is the case for the majority of baggers, we use  [walkhighlands](https://www.walkhighlands.co.uk/) for all our munro info and routes. walkhighlands is one of the unequivocally wonderful bits of the internet and I can't believe it's free. We [donate](https://www.walkhighlands.co.uk/donate.shtml) to keep it going, and if you're a bagger who uses it often, I'd encourage you to do the same. When I saw the Tidy Tuesday dataset, I knew I wanted to try and combine the provided data from the [Database of British and Irish Hills v18.2](https://www.hills-database.co.uk/) with what's available on walkhighlands.   \n\nBecause I've made certain career choices, my day-to-day activity now involves a lot less coding and a lot more admin and I realised I was starting to lose some of my R so this has been a nice excuse to refresh. I'm gearing up for another semester of teaching R to students in the age of AI and it has been interesting to reflect on how I'm using AI myself. Pleasingly, many of the solutions to the many problems I had to solve came from my knowledge of Munros and Gaelic. AI sometimes provided the code but it's a nice reminder it can only provide the answers to questions you know to ask.\n\n## Walkhighlands munro info\n\nThe reason I wanted to use walkhighlands data is that it has a bunch of route information that I could use for exploration that wasn't contained in the Database of British and Irish Hills that is the base of the Tidy Tuesday data:\n\n-   Region\n-   Estimated length of walk in hours\n-   Distance of walk\n-   Total ascent  of route (not just of each individual Munro)\n-   Route descriptions\n-   User rating of each Munro\n-   Number of ascents recorded for each Munro\n\nI contacted walkhighlands to ask permission to share what I've done and they said yes because they're lovely. I've still decided not to include the code I used for web scraping so I don't inadvertently cause them any issues and so I'll just describe roughly what I did instead.\n\nThe approach was to first scrape walkhighlands for the list of Munros, the region in which they are located, and their height from the [Munro A-Z page](https://www.walkhighlands.co.uk/munros/munros-a-z). Then it took one route for each munro (the first listed), the min and max estimated walk time, distance in km, total ascent in metres, and used regex to look for certain words that describe walk features that might be of interest (scramble, exposed, arete, river, spate, bog). walkhighlands also provides a Grade rating for each walk as well as a bog factor, however, these are represented as images, and try as I (well, AI) might, I could not get it to parse this information.\n\n![](wh_grade.png)\n\nAn important note for those of you who are familiar with walkhighlands, as highlighted, I included one route per munro - the first one listed. This can make a big difference to the walk, for example, which route you take up Ben Nevis significantly changes the fear factor and technicality. Text mining is also a blunt tool and only looks at whether a word is contained in the walk report rather than its context -  a route that reads \"there is no scrambling required\" would still have been included in the \"scramble\" category and exposure can relate to the weather or heights.\n\nIt took a long time to get the AI to provide code that worked and there were a number of issues - at one point it was matching the route to the wrong Munro, then it didn't return all Munros, then it was missing a bunch of routes. I had to manually create a file of some routes to load in because I could not find a solution as to why these handful were failing. Because I  could not have done any of this type of scraping without AI, I really have no idea why it works and why it didn't. This is intellectually unsatisfying but also, the idea you'd be willing to trust this black box of \"knowledge\" to something more serious than an obsessive deep dive into your favorite mountains is madness.\n\nHere's what the walkhighlands data looks like.\n\n```{r echo = FALSE, message = FALSE,warning = FALSE }\n\nlibrary(tidyverse)\nlibrary(flextable)\n\nwalkhighlands <- read_csv(\"walkhighlands.csv\")\n\nhead(walkhighlands, 2) |>\n  flextable()|>\n  autofit()\n```\n\n\n## Database of British and Irish Hills\n\nNext it was time to load in the Tidy Tuesday dataset which is from the Database of British and Irish Hills. In order to be able to join this with my walkhighlands database, I had to do quite a lot of wrangling although thankfully I was not reliant on AI and mainly able to achieve it because of my existing knowledge of Munros and Gaelic. \n\nI wasn't that bothered about the Munro status changes over the years as the walkhighlands database allowed me to do other more interesting analyses so I dropped these bits.\n\n\n```{r message = FALSE,warning = FALSE }\nlibrary(tidyverse)\nlibrary(fuzzyjoin)\nlibrary(ggthemes)\nlibrary(ggridges)\nlibrary(flextable)\nlibrary(stringi)\nlibrary(tidytext)\nlibrary(sf)       \nlibrary(plotly)\nlibrary(rnaturalearth)\n\nscottish_munros <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/main/data/2025/2025-08-19/scottish_munros.csv')\n\nraw_data <- read_csv(\"https://www.hills-database.co.uk/munrotab_v8.0.1.csv\")\n\nscottish_munros <- raw_data |>\n  filter(`2021` == \"MUN\") |>\n  select(\n    `DoBIH Number`, Name,\n    `Height (m)`, xcoord, ycoord, \"Grid Ref\",\n  ) |>\n  drop_na(`DoBIH Number`) |> \n  rename(\n    munro = \"Name\",\n    height = `Height (m)`,\n    number = `DoBIH Number`,\n    grid_ref = \"Grid Ref\"\n  ) \nrm(raw_data)\n```\n\n## What's in a name (issues)\n\nThe first problem to solve before trying to join the two datasets was that some of the names of the Munros differ between the two - sometimes this is because there are variants in the Gaelic (Carn Eighe/Càrn Eige), sometimes the Anglicised version is used, and sometimes it's because multiple Munros have the same name so they have additional information added in parenthesis in one of the files (Stuc an Lochain [Stuchd an Lochain]/Stùcd an Lochain).\n\n```{r}\nscottish_munros <- scottish_munros |>\n  # Standardise names in the 'dobih' dataset to Walkhighlands spellings\n  mutate(\n    munro = case_when(\n      munro == \"A' Chraileag [A' Chralaig]\" ~ \"A' Chralaig\",\n      munro == \"Beinn Challuim [Ben Challum]\" ~ \"Ben Challum\",\n      munro == \"Beinn Sheasgarnaich [Beinn Heasgarnich]\" ~ \"Beinn Heasgarnich\",\n      munro == \"Beinn a' Bhuird North Top\" ~ \"Beinn a' Bhùird\",\n      munro == \"Ben Klibreck - Meall nan Con\" ~ \"Ben Klibreck\",\n      munro == \"Blabheinn [Bla Bheinn]\" ~ \"Blà Bheinn\",\n      munro == \"Cac Carn Beag (Lochnagar)\" ~ \"Lochnagar\",\n      munro == \"Carn Eighe\" ~ \"Càrn Eige\",\n      munro == \"Carn a' Choire Bhoidheach\" ~ \"Càrn a' Choire Bhòidheach\",\n      munro == \"Creag a' Mhaim\" ~ \"Creag a'Mhàim\",\n      munro == \"Glas Leathad Mor (Ben Wyvis)\" ~ \"Ben Wyvis\",\n      munro == \"Leabaidh an Daimh Bhuidhe (Ben Avon)\" ~ \"Ben Avon\",\n      munro == \"Meall Garbh\" ~ \"Meall Garbh (Ben Lawers)\",\n      munro == \"Meall na Aighean\" ~ \"Creag Mhòr (Meall na Aighean)\",\n      munro == \"Sgurr Dearg - Inaccessible Pinnacle\" ~ \"Inaccessible Pinnacle\",\n      munro == \"Sgurr Mhor (Beinn Alligin)\" ~ \"Sgùrr Mòr (Beinn Alligin)\",\n      munro == \"Sgurr na h-Ulaidh [Sgor na h-Ulaidh]\" ~ \"Sgòr na h-Ulaidh\",\n      munro == \"Sgurr nan Ceathramhnan [Sgurr nan Ceathreamhnan]\" ~ \"Sgùrr nan Ceathreamhnan\",\n      munro == \"Stob Coir' an Albannaich\" ~ \"Stob Coir an Albannaich\",\n      munro == \"Stuc an Lochain [Stuchd an Lochain]\" ~ \"Stùcd an Lochain\",\n      munro == \"Càrn nan Gobhar (Strathfarrar)\" ~ \"Càrn nan Gobhar (Loch Mullardoch)\",\n      TRUE ~ munro\n    )\n  )\n```\n\nAfter standardising the names, to facilitate the join I also had to convert to lower case, remove accents (whether they're used differs between the datasets), and any parenthesis information from the Munro names. \n\nAfter this cleaning, because multiple Munros have the same name, I needed to join on height to distinguish them as thankfully, there aren't two Munros with the same name and height. However, a problem I wasn't anticipating is that height measurements differed between the datasets. A lot of these can be put down to rounding - walkhighlands uses whole numbers whilst the DoBIH uses two decimal places. However, this doesn't explain them all (the largest difference is 8.1 metres, that's a lot!). I don't know which one is \"correct\" or why they differ but given DoBIH is numerically more precise, I decided to use that as my measure of height in any analysis.\n\nMy AI-fuelled discovery was `fuzzyjoin` which allows you to set a tolerance level for the join and pick a best match. I've never needed this before but it provided itself to be extremely useful - with a bit of trial and error I set a tolerance of 10m and manually checked the output to ensure everything had lined up correctly.\n\n**UPDATE**: Because walkhighlands are great (honestly go and give them some money), they have updated the heights based on the DoBIH data so they now match (is this impact?).\n\n```{r}\n\n# 0) Choose a tolerance in metres (use Inf if you want “nearest regardless”)\ntol_m <- 10\n\n# 1) Normalise names in BOTH tables: remove (...) and [...], drop accents, lower-case, squish\nx <- walkhighlands %>%\n  mutate(\n    munro_key = munro %>%\n      str_replace_all(\"\\\\s*\\\\([^)]*\\\\)\", \"\") %>%   # remove text in ( )\n      str_replace_all(\"\\\\s*\\\\[[^\\\\]]*\\\\]\", \"\") %>% # remove text in [ ]\n      stri_trans_general(\"Latin-ASCII\") %>%\n      str_to_lower() %>%\n      str_squish(),\n    height = parse_number(as.character(height)),\n    row_id_x = row_number()\n  )\n\ny <- scottish_munros %>%\n  mutate(\n    munro_key = munro %>%\n      str_replace_all(\"\\\\s*\\\\([^)]*\\\\)\", \"\") %>%\n      str_replace_all(\"\\\\s*\\\\[[^\\\\]]*\\\\]\", \"\") %>%\n      stri_trans_general(\"Latin-ASCII\") %>%\n      str_to_lower() %>%\n      str_squish(),\n    height = parse_number(as.character(height)),\n    row_id_y = row_number()\n  )\n\n# 2) Fuzzy FULL join on exact munro_key + height within tolerance\ncandidates <- fuzzy_full_join(\n  x, y,\n  by = c(\"munro_key\" = \"munro_key\", \"height\" = \"height\"),\n  match_fun = list(`==`, function(a, b) abs(a - b) <= tol_m)\n) %>%\n  # standardise suffixes for older fuzzyjoin that uses .x/.y\n  rename_with(~ str_replace(.x, \"\\\\.x$\", \"_wh\")) %>%\n  rename_with(~ str_replace(.x, \"\\\\.y$\", \"_dobih\")) %>%\n  mutate(\n    height_diff = abs(height_wh - height_dobih),\n    height_diff = if_else(is.na(height_diff), Inf, height_diff)\n  )\n\n# 3) Reduce to one nearest match per row on each side, preserving FULL-join behaviour\nbest_for_left  <- candidates %>% \n  group_by(row_id_x) %>% \n  slice_min(height_diff, with_ties = FALSE) %>% \n  ungroup()\nbest_for_right <- candidates %>% \n  group_by(row_id_y) %>% \n  slice_min(height_diff, with_ties = FALSE) %>% \n  ungroup()\n\nmunro_dat <- bind_rows(best_for_left, best_for_right) %>%\n  distinct(row_id_x, row_id_y, .keep_all = TRUE) %>%\n  mutate(\n    site_key = coalesce(grid_ref, paste0(xcoord, \"_\", ycoord)),\n    munro_wh_clean = str_replace(munro_wh, \"\\\\s*\\\\([^)]*\\\\)$\", \"\")  # drop \"(Loch Mullardoch)\" etc.\n  ) %>%\n  group_by(site_key) %>%\n  slice_min(height_diff, with_ties = FALSE) %>%   # keep the single closest pair for that site\n  ungroup() %>%\n  mutate(munro_wh = munro_wh_clean) %>%\n  select(-munro_wh_clean) |>\n  mutate(time = (time_hours_min + time_hours_max) / 2) |>\n  select(-munro_dobih,-munro_key_dobih) |>\n  rename(munro = munro_wh)|>\n  mutate(scramble_exposed = case_when(\n    scramble & exposed ~ \"Both\",\n    scramble & !exposed ~ \"Scramble\",\n    !scramble & exposed ~ \"Exposed\",\n    TRUE ~ \"Neither\"\n  )) |>\n  mutate(scramble_exposed = factor(scramble_exposed,\n                                   levels = c(\"Neither\", \"Scramble\", \"Exposed\", \"Both\"))) |>\n    mutate(wet = case_when(\n    spate & bog ~ \"Both\",\n    spate & !bog ~ \"Large river\",\n    !spate & bog ~ \"Boggy\",\n    TRUE ~ \"Neither\"\n  )) |>\n  mutate(wet = factor(wet,\n                                   levels = c(\"Neither\", \"Large river\", \"Boggy\", \"Both\")))\n\n\n\nrm(x,y, best_for_left, best_for_right, candidates, tol_m, walkhighlands, scottish_munros)\n```\n\nI also created some manual colour scales on a nature theme:\n\n```{r}\n\nnature_6 <- c(\n  \"#355E3B\",  \n  \"#4B4F58\",  \n  \"#4682B4\",  \n  \"#8E6C88\",  \n  \"#E07B39\",\n  \"#BDB76B\"\n)\n\nnature_5 <- c(\n  \"#355E3B\",  \n  \"#4B4F58\",  \n  \"#4682B4\",  \n  \"#E07B39\",\n  \"#BDB76B\"\n)\n\nnature_4 <- c(\n  \"#355E3B\",  \n  \"#4B4F58\",  \n  \"#4682B4\",  \n  \"#E07B39\"   \n)\n\nnature_13 <- c(\n  \"#355E3B\",  # Pine green\n  \"#6B8E23\",  # Moss\n  \"#BDB76B\",  # Dry grass\n  \"#8B5A2B\",  # Earth brown\n  \"#D2B48C\",  # Sand\n  \"#87CEEB\",  # Sky blue\n  \"#4682B4\",  # Loch blue\n  \"#191970\",  # Mountain shadow (midnight blue)\n  \"#7D7D7D\",  # Granite grey\n  \"#A9A9A9\",  # Slate grey\n  \"#8E6C88\",  # Heather purple\n  \"#E07B39\",  # Sunset orange\n  \"#FFD700\"   # Sun yellow\n)\n```\n\n## Routes vs Munros\n\nFor some of the analyses later on, it makes more sense to do the analysis by route rather than by individual mountains - one route can have multiple Munros and the time, distance, and total ascent is for the entire route, not individually.\n\nThere are 282 Munros, but these are covered by 152 walkhighlands routes.\n\nBecause the user ratings and number of ascents are done by individual Munro rather than route, I also had to calculate the average for these for the route. It won't be completely accurate because you don't have to climb all the Munros on a given route, but given that I am just dicking about on the internet, that's probably fine.\n\n```{r}\nroute_dat <-munro_dat |>\n  select(first_route_url, first_route_title,\n         region, time_hours_min:deer_fence, time, scramble_exposed, wet) |>\n  unique()\n\nroute_stats <- munro_dat |>\n  group_by(first_route_url) |>\n  summarise(route_rating = janitor::round_half_up(mean(rating), 2),\n            route_ascents = janitor::round_half_up(mean(ascents),0 ))\n\nroute_dat <- route_dat |>\n  left_join(route_stats)\n\n```\n\n## Scrambling and exposure\n\nI have a reasonably bad fear of heights so anything that mentions scrambling or exposure worries me. First question, are higher munros scarier?\n\nBig thank you to [Jessica Moore](https://bsky.app/profile/jessimoore.bsky.social/post/3lwxw4fw5ys23) for the inspiration for this one.\n\n```{r}\nggplot(munro_dat, \n       aes(height_dobih, scramble_exposed, fill = scramble_exposed)) +\n  geom_density_ridges(quantile_lines = TRUE, quantile_fun = mean,\n                      vline_linetype = \"dashed\",\n                      aes(color = \"Mean height (m)\")) +\n  scale_y_discrete(expand = c(0.01, 0)) +\n  scale_x_continuous(expand = c(0.01, 0)) +\n  scale_color_manual(values = c(\"Mean height (m)\" = \"black\")) +\n  theme_economist() +\n  scale_fill_manual(values = nature_4) +  \n  labs(x = NULL, y = NULL,\n       title = \"Are higher Munros scarier?\",\n       colour = NULL,\n       subtitle = \"Routes descriptions that mention exposure tend to be on higher Munros\")+\n  guides(fill = \"none\") +\n  theme(legend.position = \"bottom\",\n        legend.position.inside = c(0.8,0.10))\n```\n\nFor locating the scary munros, I decided that an interactive plotly map was called for so that you can easily isolate the different types - these work much better on a full browser than a phone.\n\nHave I mentioned that I dislike heights and exposure?\n\n```{r}\nmunros_map <- munro_dat %>%\n  select(munro, region, xcoord, ycoord, height_dobih, scramble_exposed, wet, toilet, pub, bothy, deer_fence, car_park, wood) %>%\n  na.omit()\n\n# Convert OSGB36 coordinates to sf object\nmunros_sf <- munros_map %>%\n  st_as_sf(coords = c(\"xcoord\", \"ycoord\"), \n           crs = 27700)  # EPSG:27700 is OSGB36 / British National Grid\n\n# Transform to WGS84 (lat/long) for easier plotting\nmunros_lat_long <- munros_sf %>%\n  st_transform(crs = 4326)\n\n# Extract coordinates for ggplot\nmunros_coords <- munros_lat_long %>%\n  mutate(\n    longitude = st_coordinates(.)[,1],\n    latitude = st_coordinates(.)[,2]\n  ) %>%\n  st_drop_geometry() %>%\n  arrange(-height_dobih)\n\n\nuk_map <- rnaturalearth::ne_countries(scale = \"large\", \n                                  country = \"United Kingdom\", \n                                    returnclass = \"sf\")\n\n# Step 2: Specify shape codes (16 = circle, 17 = triangle, etc.)\nshape_values <- c(\n  \"Neither\" = 16,    # filled circle\n  \"Scramble\" = 17,   # filled triangle\n  \"Exposed\" = 15,    # filled square\n  \"Both\" = 18        # filled diamond\n)\n\np <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56.5, 58.6)) +\n  geom_jitter(data = munros_coords, \n             aes(x = longitude, \n                 y = latitude, \n                 shape = scramble_exposed, \n                 colour = scramble_exposed,\n                 text = munro), \n             size = 1,\n             height = .05,\n             width = .05) + \n  scale_x_continuous(breaks = NULL) +\n  scale_shape_manual(values = shape_values) +\n  scale_y_continuous(breaks = NULL) +\n  scale_colour_manual(values = nature_4) +\n  labs(title = \"Where are the scary Munros?\",\n       subtitle = \"Walk descriptions that reference:\",\n       colour = \"Route mentions\", shape = \"Route mentions\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(p, tooltip = \"text\")\n```\n\n## By region\n\nI also thought it would be fun to look into regional differences. The munros vary massively in character depending on where you are in the country (you can imagine hobbits living in Cairngorms whilst Skye would be home to dragons), but how is this reflected in the walk features?\n\n### Regional map\n\nWhich Munros are in which region is taken from the [walkhighlands A-Z](https://www.walkhighlands.co.uk/munros/munros-a-z) but I've had a few people ask since posting this, so here's an easy to read map.\n\n```{r}\np3 <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56.5, 58.6)) +\n  geom_jitter(data = munros_coords, \n             aes(x = longitude, \n                 y = latitude, \n                 colour = region,\n                 text = munro), \n             size = 1,\n             height = .05,\n             width = .05) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  scale_colour_manual(values = nature_13) +\n  labs(title = \"Munros by region\",\n       colour = NULL) +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(p3, tooltip = \"text\")\n```\n\nAnd here's the counts for how many Munros and routes are in each region. It's highly correlated, but the ranks do change a little.\n\n```{r}\nmunro_region <- munro_dat |>\n  count(region, sort = TRUE) |>\n  rename(\"munros\" = \"n\") \n\nroute_region <- route_dat |>\n  count(region, sort = TRUE) |>\n  rename(\"routes\" = \"n\")\n\ninner_join(munro_region, route_region) |>\n  flextable()|>\n  autofit()\n```\n\n### Tallest Munros\n\nWhich region has the tallest Munros?\n\n```{r}\n\nregion_height <- munro_dat |>\n  group_by(region) |>\n  summarise(avg_height = mean(height_dobih, na.rm = TRUE), .groups = \"drop\") |>\n  slice_max(avg_height, n = 5)\n\nggplot(\n  semi_join(munro_dat, region_height, by = \"region\"),\n  aes(\n    x = height_dobih,\n    y = fct_reorder(region, height_dobih, .fun = mean, .desc = FALSE),\n    fill = region\n  )\n)  +\n  geom_density_ridges(\n    quantile_lines = TRUE, quantile_fun = mean,\n    vline_linetype = \"dashed\",\n    aes(colour = \"Mean height (m)\")\n  ) +\n  scale_y_discrete(expand = c(0.01, 0)) +\n  scale_x_continuous(expand = c(0.01, 0)) +\n  scale_colour_manual(values = c(\"Mean height (m)\" = \"black\")) +\n  theme_economist() +\n  scale_fill_manual(values = nature_5) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Which region has the highest Munros?\",\n    colour = NULL,\n    subtitle = \"Top 5 regions displayed. On average, Loch Ness has the highest Munros\"\n  ) +\n  guides(fill = \"none\") +\n  theme(\n    legend.position = \"inside\",\n   legend.position.inside = c(0.8, 0.1),\n    legend.text = element_text(size = 10)\n  )\n```\n\nAnd fere's the full list in table form:\n\n```{r}\nmunro_dat |>\n  group_by(region) |>\n  summarise(avg_height = mean(height_dobih, na.rm = TRUE), .groups = \"drop\") |>\n  arrange(desc(avg_height)) |>\n  flextable() |>\n  colformat_double(digits = 0)|>\n  autofit()\n```\n\n### Longest routes\n\nWhich region has the longest routes on average by distance?\n\nThis plot uses the route data although I am pleased that the order remains the same if you use the munro data (because I only realised I should do it by route after I shared this publicly).\n\n```{r}\n\n# Top 5 regions by mean distance\nregion_distance <- route_dat |>\n  group_by(region) |>\n  summarise(avg_distance = mean(distance_km, na.rm = TRUE), .groups = \"drop\") |>\n  slice_max(avg_distance, n = 5)\n\n# Keep only those regions in the raw data\ntop_dat <- semi_join(route_dat, region_distance, by = \"region\")\n\n\nggplot(\n  top_dat,\n  aes(\n    x = distance_km,  # use the per-route variable here\n    y = fct_reorder(region, distance_km, .fun = mean, .desc = FALSE),\n    fill = region\n  )\n) +\n  geom_density_ridges(\n    quantile_lines = TRUE, quantile_fun = mean,\n    vline_linetype = \"dashed\",\n    aes(colour = \"Mean distance (km)\")\n  ) +\n  scale_y_discrete(expand = c(0.01, 0)) +\n  scale_x_continuous(expand = c(0.01, 0)) +\n  scale_colour_manual(values = c(\"Mean distance (km)\" = \"black\")) +\n  theme_economist() +\n  scale_fill_manual(values = nature_5) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Which region has the longest walks?\",\n    colour = NULL,\n    subtitle = \"Top 5 regions displayed. On average, Loch Ness has the longest walks\"\n  ) +\n  guides(fill = \"none\") +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(0.82, .1),\n    legend.text = element_text(size = 10)\n    )\n```\n\nAnd here's the full list in table form:\n\n```{r}\nroute_dat |>\n  group_by(region) |>\n  summarise(avg_distance = mean(distance_km, na.rm = TRUE), .groups = \"drop\") |>\n  arrange(desc(avg_distance)) |>\n  flextable() |>\n  colformat_double(digits = 2)|>\n  autofit()\n```\n\n### Most ascent\n\nWhich region has the most ascent per route?\n\nAgain the order doesn't change if you use routes or Munros as the data (the exact values do slightly but not the rank).\n\n```{r}\n# Top 5 regions by mean distance\nregion_ascent <- munro_dat |>\n  group_by(region) |>\n  summarise(avg_ascent = mean(ascent, na.rm = TRUE), .groups = \"drop\") |>\n  slice_max(avg_ascent, n = 5)\n\n# Keep only those regions in the raw data\ntop_ascent <- semi_join(munro_dat, region_ascent, by = \"region\")\n\n\nggplot(\n  top_ascent,\n  aes(\n    x = ascent,  # use the per-route variable here\n    y = fct_reorder(region, ascent, .fun = mean, .desc = FALSE),\n    fill = region\n  )\n) +\n  geom_density_ridges(\n    quantile_lines = TRUE, quantile_fun = mean,\n    vline_linetype = \"dashed\",\n    aes(colour = \"Mean ascent (m)\")\n  ) +\n  scale_y_discrete(expand = c(0.01, 0)) +\n  scale_x_continuous(expand = c(0.01, 0)) +\n  scale_colour_manual(values = c(\"Mean ascent (m)\" = \"black\")) +\n  theme_economist() +\n  scale_fill_manual(values = nature_5) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Which region has the most ascent?\",\n    colour = NULL,\n    subtitle = \"Top 5 regions displayed. On average, Loch Ness has the most ascent\"\n  ) +\n  guides(fill = \"none\") +\n  theme(\n    legend.position = \"inside\",\n    legend.position.inside = c(0.82, .1),\n    legend.text = element_text(size = 10)  \n    )\n```\n\nAnd here's the full list in table form:\n\n```{r}\nroute_dat |>\n  group_by(region) |>\n  summarise(avg_ascent = mean(ascent, na.rm = TRUE), .groups = \"drop\") |>\n  arrange(desc(avg_ascent)) |>\n  flextable() |>\n  colformat_double(digits = 0)|>\n  autofit()\n```\n\n### Munros per route\n\nWhere do you get the most bang for your buck? \n\n```{r}\n\nmunro_dat |>\n  count(region, first_route_title, name = \"n\") |>\n  group_by(region) |>\n  summarise(avg_count = mean(n), .groups = \"drop\") |>\n  ggplot(aes(\n    x = fct_reorder(region, avg_count),\n    y = avg_count,\n    fill = region\n  )) +\n  geom_col() +\n  scale_fill_manual(values = nature_13) +\n  coord_flip() +\n  guides(fill = \"none\") +\n  labs(x = NULL, y = \"Number of Munros\",\n       title = \"Average number of Munros bagged per route\") +\n  theme_economist()\n```\n\n### User ratings\n\nWhich region has the highest and lowest rated Munros (by user rating)?\n\n```{r}\nregion_rating_top <- munro_dat |>\n  group_by(region) |>\n  summarise(avg_rating = mean(rating, na.rm = TRUE), \n            n = n(),\n            .groups = \"drop\") |>\n  filter(n >= 5)|>\n  slice_max(avg_rating, n = 3)\n\n# bottom 3\n\nregion_rating_bottom <- munro_dat |>\n  group_by(region) |>\n  summarise(avg_rating = mean(rating, na.rm = TRUE), \n            n = n(),\n            .groups = \"drop\") |>\n  filter(n >= 5)|>\n  slice_min(avg_rating, n = 3)\n\nregion_top_bottom <-bind_rows(region_rating_top, region_rating_bottom)\n\nggplot(\n  semi_join(munro_dat, region_top_bottom, by = \"region\"),\n  aes(\n    x = rating,\n    y = fct_reorder(region, rating, .fun = mean, .desc = FALSE),\n    fill = region\n  )\n)  +\n  geom_density_ridges(\n    quantile_lines = TRUE, quantile_fun = mean,\n    vline_linetype = \"dashed\",\n    aes(colour = \"Mean height (m)\")\n  ) +\n  scale_y_discrete(expand = c(0.01, 0)) +\n  scale_x_continuous(expand = c(0.01, 0)) +\n  scale_colour_manual(values = c(\"Mean height (m)\" = \"black\")) +\n  theme_economist() +\n  scale_fill_manual(values = nature_6) +\n  labs(\n    x = NULL, y = NULL,\n    title = \"Which region has the highest user rated Munros?\",\n    colour = NULL,\n    subtitle = \"Top & bottom 3 (regions w/ 5+ Munros)\"\n  ) +\n  guides(fill = \"none\") +\n  theme(\n    legend.position = \"inside\",\n   legend.position.inside = c(0.87, 0.1),\n    legend.text = element_text(size = 10)\n  )\n\n```\n\nAnd here's the full list in table form:\n\n```{r}\nmunro_dat |>\n  group_by(region) |>\n  summarise(avg_rating = mean(rating, na.rm = TRUE), \n            \"no. munros\" = n(),.groups = \"drop\") |>\n  arrange(desc(avg_rating)) |>\n  flextable() |>\n  colformat_double(digits = 2)|>\n  autofit()\n```\n\n### Ascents by rating\n\nNumber of ascents (how many people have recorded on walkhighlands that they have summitted a particular Munro) by ratings\n\n```{r}\nggplot(route_dat, aes(x = route_ascents, y = route_rating)) +\n  geom_point(aes(text = first_route_url)) +\n  theme_economist() +\n  scale_y_continuous(breaks = seq(1:5)) +\n  coord_cartesian(ylim = c(1,5)) +\n  labs(y = \"User rating (1-5)\",\n       x = \"Number of recorded ascents\",\n       title = \"Number of ascents by rating\")+\n  annotate(geom = \"curve\", \n          x = 31000, y = 3, \n          xend = 31800, yend = 3.75,\n          curvature = 0.3,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 31000, y = 2.8,\n           label = \"Ben Lomond\")+\n  annotate(geom = \"curve\", \n          x = 23000, y = 1.45, \n          xend = 18900, yend = 2.30,\n          curvature = -0.3,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 28000, y = 1.45,\n           label = \"The Cairnwell Munros\") +\n  annotate(geom = \"curve\", \n          x = 5559, y = 1.5, \n          xend = 5559, yend = 4.61,\n          curvature = -0.55,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 7600, y = 1.35,\n           label = \"Sgùrr nan Gillean\")\n\n\n\n\n```\n\nAnd then as an interactive plot:\n\n```{r}\np5 <- ggplot(route_dat, aes(x = route_ascents, y = route_rating)) +\n  geom_point(aes(text = first_route_title)) +\n  theme_economist() +\n  scale_y_continuous(breaks = seq(1:5)) +\n  coord_cartesian(ylim = c(1,5)) +\n  labs(y = \"User rating (1-5)\",\n       x = \"Number of recorded ascents\",\n       title = \"Number of ascents per route by rating\")\n\nggplotly(p5)\n```\n\n## Ascent (m)\n\nAs you would expect, total ascent correlates strongly with total time, but there are some points of interest. Bidein a' Choire Sheasgaich and Lurg Mhòr have the longest estimated walk time but their remoteness means that they're an outlier in terms of the amount of ascent you'd expect for that time. The Fisherfield 6 claim the prize for most ascent by some distance but are bang on in terms of the ascent/time relationship. Meall Buidhe wins the award for being the quickest munro to bag, with the least ascent.\n\n\n```{r}\nggplot(route_dat, aes(x = ascent, y = time)) +\n  geom_jitter(height = .05, width = .05) +\n  scale_x_continuous(breaks = seq(500, 2500, 250)) +\n  scale_y_continuous(breaks = seq(0, 20, 2)) +\n  annotate(geom = \"curve\", \n          x = 1200, y = 15, \n          xend = 1450, yend = 16,\n          curvature = -0.3,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 1150, y = 14.5,\n           label = \"Bidein a' Choire Sheasgaich\\nand Lurg Mhòr\") +\n    annotate(geom = \"curve\", \n          x = 2050, y = 13.5, \n          xend = 2220, yend = 15,\n          curvature = -0.3,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 2100, y = 13,\n           label = \"Fisherfield 6\")+\n    annotate(geom = \"curve\", \n          xend = 575, yend = 2.9, \n          x = 1250, y = 4,\n          curvature = 0.2,\n          arrow = arrow(length = unit(0.5, \"lines\"))) +\n    annotate(\"text\",\n           x = 1450, y = 4.5,\n           label = \"Meall Buidhe\")+\n  theme_economist()  +\n  labs(x = \"Ascent (m)\", \n       y = \"Time (hours)\",\n       title = \"Total ascent by time\") +\n    theme(legend.position = \"inside\",\n    axis.title.x = element_text(margin = margin(t = 8)),\n    axis.title.y = element_text(margin = margin(r = 8)),\n    legend.position.inside = c(0.9, .2),\n    legend.text = element_text(size = 10)  \n  )\n```\n\n\nAnd here's an interactive version of that plot that adds in scrambling and exposure because had I mentioned, I am scared of heights. \n\n```{r}\np1 <- ggplot(route_dat, aes(x = ascent, y = time)) +\n  geom_jitter(aes(shape = scramble_exposed, \n                 colour = scramble_exposed,\n                 text = first_route_title), \n             size = 1) +\n  scale_x_continuous(breaks = seq(500,2500, 250)) +\n  scale_y_continuous(breaks = seq(0,20,2)) +\n  scale_shape_manual(values = shape_values) +\n  scale_colour_manual(values= nature_4) +\n  labs(x = \"Ascent (m)\", \n       y = \"Time (hours)\",\n       title = \"Ascent by time\",\n       shape = \"Route mentions\",\n       colour = \"Route mentions\") +\n  theme_economist() +\n  theme(\n    axis.title.x = element_text(margin = margin(t = 8)),\n    axis.title.y = element_text(margin = margin(r = 8)),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(p1, tooltip = \"text\")\n\n```\n\n## Where's wet?\n\nIf the text-mining for scrambling and exposure is a blunt tool then my approach here is even blunter. There are multiple words I could have searched for regarding the presence of water - river, stream, burn - but many of those represent features that don't make a difference to the walk if they present no difficulty (\"cross the bridge over the river\"). I decided to use the word \"spate\" because when the river is large, walkhighlands often highlights that it would be difficult or impossible to cross \"in spate\". \n\nSo these aren't all the rivers, just ones where the description indicates crossing them might present an issue.\n\n```{r}\n\nshape_values <- c(\n  \"Neither\" = 16,    # filled circle\n  \"River\" = 17,   # filled triangle\n  \"Boggy\" = 15,    # filled square\n  \"Both\" = 18        # filled diamond\n)\n\np2 <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56.5, 58.6)) +\n  geom_jitter(data = munros_coords, \n             aes(x = longitude, \n                 y = latitude, \n                 shape = wet, \n                 colour = wet,\n                 text = munro), \n             size = 1,\n             height = .05,\n             width = .05) + \n  scale_x_continuous(breaks = NULL) +\n  scale_shape_manual(values = shape_values) +\n  scale_y_continuous(breaks = NULL) +\n  scale_colour_manual(values = nature_4) +\n  guides(shape = \"none\") +\n  labs(title = \"Where is wet?\\n(Everywhere, it's Scotland)\",\n              subtitle = \"Walk descriptions that reference:\",\n       colour = \"Route mentions\", shape = \"Route mentions\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(p2, tooltip = \"text\")\n```\n\n## Woodland\n\nI've been fortunate enough to go hiking in Switzerland and Albania this year and it has did highlight to me how bare the Munros often are, thanks to destrctuive logging and farming practices.\n\n```{r}\nwood_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, wood == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 text = munro, colour = \"#355E3B\"), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention woodland\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(wood_plot, tooltip = \"text\")\n```\n\n\n```{r}\nmunro_dat |>\n  count(region, wood) |>\n  group_by(region) |>\n  mutate(percent = janitor::round_half_up(n/sum(n)*100,0)) |>\n  filter(wood == TRUE) |>\n  ungroup() |>\n  arrange(desc(percent)) |>\n  select(-wood, -n) |>\n  flextable() |>\n  set_caption(caption = \"Percent of routes that mention woodland\")\n\n# 10 greens for manual scales (light → dark)\ngreens_10 <- grDevices::colorRampPalette(\n  c(\"#00441b\", \"#006d2c\", \"#238b45\", \"#41ab5d\", \"#74c476\")\n)(10)\n\n\nmunro_dat |>\n  count(region, wood) |>\n  group_by(region) |>\n  mutate(percent = janitor::round_half_up(n / sum(n) * 100, 0)) |>\n  filter(wood) |>\n  ungroup() |>\n  mutate(region = forcats::fct_reorder(region, percent, .desc = FALSE)) |>\n  ggplot(aes(x = region, y = percent, fill = region)) +\n  geom_col() +\n  scale_fill_manual(values = rev(greens_10)) +\n  guides(fill = \"none\") +\n  coord_flip() +\n  scale_y_continuous(breaks = seq(0, 100, 10)) +\n  theme_economist() +\n  labs(x = NULL, y = NULL,\n       title = \"Percent of routes that mention woodland by region\")\n\n```\n\n\n\n\n## Non-natural features\n\nWith the usual caveats about the limits of text mining, here's some maps showing route descriptions that mention non-natural features (bothy, deer fence (because they're scary), pub, toilet). Some of these are more useful than others. \n\n### Bothy\n\n```{r}\nbothy_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, bothy == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 colour = bothy,\n                 text = munro), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention a bothy\") +\n  guides(colour = \"none\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(bothy_plot, tooltip = \"text\")\n```\n\n### Deer fences\n\nI really hate deer fences. \n\n```{r}\nfence_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, deer_fence == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 colour = deer_fence,\n                 text = munro), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention a deer fence\") +\n  guides(colour = \"none\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(fence_plot, tooltip = \"text\")\n```\n\n### Toilets\n\nWhat I learned making this plot is that I cannot spell toilet. I lost an hour of my life to realising the error was coming from \"toliet\". \n\n```{r}\n\ntoilet_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, toilet == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 colour = toilet,\n                 text = munro), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention a toilet\") +\n  guides(colour = \"none\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(toilet_plot, tooltip = \"text\")\n```\n\n### Pubs\n\nThis one wasn't really worth doing given how few routes mention a pub, but for Sandie, anything. \n\n```{r}\npub_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, pub == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 colour = pub,\n                 text = munro), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention a pub\") +\n  guides(colour = \"none\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(pub_plot, tooltip = \"text\")\n```\n\n\n### Car parks\n\n```{r}\ncar_plot <- ggplot() +\n  geom_sf(data = uk_map, fill = \"lightgray\", color = \"darkgrey\", size = 0.3) +\n  coord_sf(xlim = c(-8, -1.5), ylim = c(56, 58.6)) +\n  geom_jitter(data = filter(munros_coords, car_park == TRUE), \n             aes(x = longitude, \n                 y = latitude, \n                 colour = pub,\n                 text = munro), \n             size = 1) + \n  scale_x_continuous(breaks = NULL) +\n  scale_y_continuous(breaks = NULL) +\n  labs(title = \"Routes that mention a car park\") +\n  guides(colour = \"none\") +\n  theme_economist() +\n  theme(\n    axis.text = element_blank(),      \n    axis.ticks = element_blank(),     \n    axis.title = element_blank(),     \n    panel.grid = element_blank(),     \n    panel.border = element_blank(),\n    legend.text = element_text(size = 10)\n  )\n\nggplotly(car_plot, tooltip = \"text\")\n```\n\n\n## Best and worst Munros\n\nI was asked by [Kate Gilliver](https://bsky.app/profile/penarthkate.bsky.social) via Bluesky \"which Munro is the ultimate combination of high, exposed, scary, remote, boggy, rivery and generally to be avoided?\"\n\nSo with the following criteria:\n\n- Doesn't mention bog, river, scramble, exposed, or a deer fence\n- Takes 6 hours or less\n\nYour top 5 choices by user rating are.....\n\n```{r}\nroute_dat |>\n  filter(bog == FALSE,\n         river == FALSE,\n         scramble == FALSE,\n         exposed == FALSE,\n         deer_fence == FALSE,\n         time <= 6) |>\n  arrange(desc(route_rating)) |>\n  select(route = first_route_title, region, route_rating) |>\n  slice(1:5) |>\n  flextable()|>\n  autofit()\n```\n\n\nIf you want a scary but dry hike:\n\n- No bog or river\n- But scramble and exposed\n- Top 5 by user rating\n\n```{r}\nroute_dat |>\n  filter(bog == FALSE,\n         river == FALSE,\n         scramble == TRUE,\n         exposed == TRUE) |>\n  arrange(desc(route_rating)) |>\n  select(route = first_route_title, region, route_rating) |>\n  slice(1:5) |>\n  flextable()|>\n  autofit()\n```\n\n\nAnd if you want to hate yourself:\n\n- Bog and river\n- More than 6 hours\n- More than 1000 metres of ascent\n- Lowest rated by users\n\n```{r}\nroute_dat |>\n  filter(bog == TRUE,\n         river == TRUE,\n         time >6,\n         ascent > 1000) |>\n  arrange(route_rating) |>\n  select(route = first_route_title, region, route_rating) |>\n  slice(1:5) |>\n  flextable()|>\n  autofit()\n```\n\n\nI may have become a bit obsessed.\n\nI must stop.\n\nBut if you have any other suggestions for analysis....just ask."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../../styles.css"],"output-file":"index.en.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.21","date-format":"long","resources":["images/**","files/**"],"theme":{"light":"cosmo","dark":"slate"},"toggle":true,"title":"Munro Tidy Tuesday","author":"Emily Nordmann","date":"2025-08-31","slug":"munro-tidy-tuesday","code-summary":"Show code","toc-location":"left"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}